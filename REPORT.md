Perfect—here’s a build spec your Cursor AI can chew on and generate the stack quickly.

---

# Multibot Orchestrator – Build Spec (Local+ngrok → GCE VM)

**Goal:** Single orchestrator with three modules—**Router → Planner → Executor**—capable of:

* Selecting the right service (CompanyCam, AccuLynx, ECi Bolt, Slack).
* Planning multi-step API workflows from OpenAPI docs.
* Executing **API calls** and **shell commands** (explicitly allowed), with full audit logs, disambiguation prompts, and a minimal chat UI.

You’ll prototype locally, tunnel with ngrok, then lift-and-shift to a Google Cloud VM using the **same Docker images**.

---

## 0) Tech Choices (opinionated for speed + maintainability)

* **Language:** TypeScript (Node 20)
* **Backend:** Fastify + Zod + OpenAI SDK (function calling) + Prisma
* **UI:** Next.js (App Router), minimal chat UI, your company logo in header
* **DB:** Supabase (Postgres) via Prisma (`DATABASE_URL` from Supabase)
* **Auth (initial):** Single-user “dev token” via `.env`; add real auth later
* **Container:** Docker for both `api` and `web`; Compose orchestrates both
* **Logging:** Pino (structured)
* **Tests:** Vitest + Nock (HTTP mocks)
* **Process manager (VM):** Docker Compose (simple) or systemd + Compose

---

## 1) Repo Layout (monorepo)

```
multibot/
  apps/
    api/
      src/
        server.ts
        router/
          serviceRouter.ts
        planner/
          planner.ts
          prompts.ts
          schemas.ts
        executor/
          index.ts
          toolRegistry.ts
          commandRunner.ts
          httpClient.ts
        action-packs/
          companycam/
            config.json
            client.ts
            tools.ts
            workflows.ts
            generated/
              types.d.ts           // from OpenAPI
          acculynx/
            ...
          bolt/
            ...
          slack/
            ...
        storage/
          supabase.ts
        telemetry/
          logger.ts
        middleware/
          auth.ts
          error.ts
        types/
          index.ts
      prisma/
        schema.prisma
        migrations/               // generated by prisma migrate
      .env.example
      Dockerfile
      package.json
    web/
      app/
        layout.tsx
        page.tsx
        api/
          chat/route.ts           // proxies to api service or uses shared client
      public/
        logo.png                   // place your company logo here
      Dockerfile
      next.config.mjs
      package.json
  packages/
    shared/
      index.ts                    // shared types/constants
  assets/
    openapi/
      companycam.yaml
      acculynx.yaml
      eci-bolt.yaml
      slack.yaml
  scripts/
    ingest-openapi.ts             // generates types from assets/openapi/*.yaml
  docker-compose.yml
  README.md
```

---

## 2) Environment & Secrets

Create `apps/api/.env` and `apps/web/.env` based on `.env.example`.

**Required (api):**

```
OPENAI_API_KEY=...
DATABASE_URL=postgresql://[supabase-user]:[pass]@[host]:5432/[db]?sslmode=require
ALLOW_SHELL=1                      # you asked for any shell commands (see guardrails below)
COMMAND_MODE=SANDBOX|HOST          # default SANDBOX; set HOST only if you truly need host exec
NGROK_URL=https://your.ngrok.io    # optional; used in returned links if behind tunnel
AUTH_DEV_TOKEN=local-dev-only      # simple bearer token until proper auth
```

**Per-service API keys (only add what you enable):**

```
COMPANYCAM_API_KEY=...
ACCULYNX_API_KEY=...
BOLT_API_KEY=...
SLACK_BOT_TOKEN=...
```

**Web (optional):**

```
NEXT_PUBLIC_API_BASE_URL=http://localhost:8080
```

> *Production on GCE VM:* copy these `.env` files or use Docker secrets. Never bake keys into images.

---

## 3) Supabase (Postgres) Schema (Prisma)

`apps/api/prisma/schema.prisma` (core tables only—expand as needed):

```prisma
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }
generator client { provider = "prisma-client-js" }

model User {
  id        String   @id @default(cuid())
  email     String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Conversation {
  id        String   @id @default(cuid())
  title     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  messages  Message[]
}

model Message {
  id             String   @id @default(cuid())
  role           String   // user | assistant | system
  content        String
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  createdAt      DateTime @default(now())
}

model Task {
  id          String   @id @default(cuid())
  service     String   // "companycam" | "acculynx" | ...
  intent      String   // canonical intent
  inputs      Json
  status      String   // planned | awaiting_user | executing | done | error
  result      Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  conversationId String?
}

model Step {
  id        String @id @default(cuid())
  taskId    String
  index     Int
  action    String   // e.g., "companycam.search_project"
  args      Json
  output    Json?
  status    String   // pending | running | done | error
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  task      Task    @relation(fields: [taskId], references: [id])
}

model ApiCall {
  id        String @id @default(cuid())
  service   String
  method    String
  url       String
  request   Json
  response  Json?
  status    Int?
  latencyMs Int?
  createdAt DateTime @default(now())
  taskId    String?
  stepId    String?
}

model CommandRun {
  id        String @id @default(cuid())
  command   String
  args      String?
  cwd       String?
  mode      String // SANDBOX|HOST
  exitCode  Int?
  stdout    String?
  stderr    String?
  durationMs Int?
  createdAt DateTime @default(now())
  taskId    String?
  stepId    String?
}

model ServiceConfig {
  id        String @id @default(cuid())
  service   String @unique
  enabled   Boolean @default(true)
  openapiRef String // path to YAML/JSON (assets/openapi/*.yaml)
  synonyms  String  // CSV or JSON list for routing
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

Run:

```
cd apps/api
pnpm i
pnpm prisma migrate dev
```

---

## 4) Where to put API documentation & how to enable services

* Place each OpenAPI file under: `assets/openapi/<service>.yaml`

  * `assets/openapi/companycam.yaml`
  * `assets/openapi/acculynx.yaml`
  * `assets/openapi/eci-bolt.yaml`
  * `assets/openapi/slack.yaml`
* Tell the system **which APIs to enable** via `apps/api/src/action-packs/<service>/config.json`:

```json
{
  "service": "companycam",
  "openapiRef": "../../../assets/openapi/companycam.yaml",
  "enabled": true,
  "synonyms": ["company cam", "companycam", "ccam", "photos app"],
  "operations": {
    "search_project": {
      "summary": "Find a project by name/address",
      "method": "GET",
      "path": "/v1/projects",
      "query": ["name","address"]
    },
    "create_project_conversation": {
      "summary": "Create conversation on project",
      "method": "POST",
      "path": "/v1/projects/{project_id}/conversations",
      "body": ["message"]
    }
  }
}
```

> **You control scope** by editing `operations` to list only the endpoints you want this system to use. For each new vendor, drop their OpenAPI file in `assets/openapi/` and add a matching `config.json`.

**Types generation:** run `pnpm tsx scripts/ingest-openapi.ts` to generate `generated/types.d.ts` per service. (Use `openapi-typescript` lib.)

---

## 5) Core Contracts

### 5.1 TaskSpec (Planner output)

```ts
// apps/api/src/planner/schemas.ts
import { z } from "zod";

export const TaskSpec = z.object({
  service: z.enum(["companycam","acculynx","bolt","slack"]),
  intent: z.string(), // e.g., "add_project_conversation"
  inputs: z.object({
    project_hint: z.object({
      name: z.string().optional(),
      address: z.string().optional()
    }).optional(),
    message: z.string().optional(),
    // generic bag for other services
    extra: z.record(z.any()).optional()
  })
});

export type TaskSpec = z.infer<typeof TaskSpec>;
```

### 5.2 Capability Graph (hand-authored workflows)

```ts
// apps/api/src/action-packs/companycam/workflows.ts
export const workflows = {
  add_project_conversation: [
    { action: "companycam.search_project", bind: { name: "inputs.project_hint.name", address: "inputs.project_hint.address" }, out: "project_id" },
    { action: "companycam.create_project_conversation", bind: { project_id: "$prev.project_id", message: "inputs.message" } }
  ]
} as const;
```

### 5.3 Tool Registry (Executor tools)

```ts
// apps/api/src/executor/toolRegistry.ts
import { z } from "zod";
import { companycamTools } from "../action-packs/companycam/tools";
import { runCommandTool } from "./commandRunner";

export const tools = {
  ...companycamTools,
  "system.run_command": runCommandTool
};

// Example companycam tool shapes:
export const schemas = {
  "companycam.search_project": z.object({ name: z.string().optional(), address: z.string().optional() }),
  "companycam.create_project_conversation": z.object({ project_id: z.string(), message: z.string().min(1) }),
  "system.run_command": z.object({ command: z.string(), cwd: z.string().optional(), timeoutMs: z.number().int().positive().max(300000).optional(), mode: z.enum(["SANDBOX","HOST"]).optional() })
};
```

---

## 6) Router → Planner → Executor

### 6.1 Router (service selection)

* Prefer **explicit mentions** (e.g., “in companycam …”).
* Else use fuzzy match against `ServiceConfig.synonyms`.
* If still < threshold → **ask disambiguation** (always prompt back per your requirement).

```ts
// apps/api/src/router/serviceRouter.ts
export function routeService(userText: string, services: Array<{service:string; synonyms:string[]}>) {
  const lower = userText.toLowerCase();
  for (const s of services) {
    if ([s.service, ...s.synonyms].some(v => lower.includes(v.toLowerCase()))) {
      return { service: s.service, confidence: 0.99 };
    }
  }
  return { service: null, confidence: 0.0 };
}
```

### 6.2 Planner (LLM creates TaskSpec + plan)

* Use OpenAI function-calling with a **single tool**: `emit_task_spec(TaskSpec schema)`.
* If inputs are insufficient or ambiguous: **return a `needs_clarification` message** the UI will show to the user.

```ts
// apps/api/src/planner/planner.ts (pseudo)
import OpenAI from "openai";
import { TaskSpec } from "./schemas";
export async function planTask(userText: string, serviceHint?: string) {
  const system = `You are a planner. Output only a valid TaskSpec or a single question for clarification. Disambiguation is mandatory when uncertain.`;
  const tool = {
    type: "function",
    function: {
      name: "emit_task_spec",
      parameters: TaskSpec
    }
  };
  // call openai with messages + tool definitions; parse back TaskSpec
}
```

**Prompt snippets (`prompts.ts`)** should include examples for CompanyCam, AccuLynx, etc., making it crystal-clear that:

* Disambiguate before execution.
* Use the minimal steps to achieve the intent.

### 6.3 Executor (runs workflows)

* Loads Action Pack workflow for given `intent`.
* Binds args from TaskSpec.
* Executes each `action` in order.
* On branching ambiguity (e.g., multiple projects): **pause** and return a question + candidate list for the UI to present.

```ts
// apps/api/src/executor/index.ts (pseudo)
export async function executeTask(task: TaskSpec, askUser: (q:string, choices?:any[])=>Promise<any>) {
  const wf = workflowsByService[task.service][task.intent];
  let prev: any = {};
  for (const step of wf) {
    const args = bindArgs(step.bind, task, prev);
    const result = await tools[step.action](args);  // validated via schema
    // handle ambiguity -> askUser(...)
    prev = {...prev, ...result};
  }
  return prev;
}
```

---

## 7) Command Runner (dangerous by design; guarded)

* **Modes:**

  * `SANDBOX` (default): run in ephemeral container, e.g., `docker run --rm alpine sh -lc "<cmd>"`.
  * `HOST`: run directly on host via Node `child_process.spawn` with `shell: true`.
* **Controls:**

  * Require `ALLOW_SHELL=1`.
  * Require user confirmation in UI (Plan Preview → “Run command”).
  * Enforce timeout (default 60s; configurable via `timeoutMs`).
  * Log stdout/stderr to `CommandRun` table.
  * Redact secrets in logs (basic pattern list).

```ts
// apps/api/src/executor/commandRunner.ts
import { execa } from "execa";
export const runCommandTool = async ({ command, cwd, timeoutMs = 60000, mode = process.env.COMMAND_MODE ?? "SANDBOX" }) => {
  if (process.env.ALLOW_SHELL !== "1") throw new Error("Shell disabled");
  const start = Date.now();
  if (mode === "SANDBOX") {
    // requires docker installed
    const full = `docker run --rm -v ${cwd ?? process.cwd()}:/work -w /work alpine:3.20 sh -lc ${JSON.stringify(command)}`;
    const { stdout, stderr, exitCode } = await execa("sh", ["-lc", full], { timeout: timeoutMs });
    return { stdout, stderr, exitCode, durationMs: Date.now()-start };
  } else {
    const { stdout, stderr, exitCode } = await execa("sh", ["-lc", command], { cwd, timeout: timeoutMs });
    return { stdout, stderr, exitCode, durationMs: Date.now()-start };
  }
};
```

---

## 8) Action Packs (per service)

Each service folder contains:

* `config.json` (see §4)
* `client.ts` (thin HTTP wrapper; injects API key; retries; logs to `ApiCall`)
* `tools.ts` (Zod-validated tool funcs that call `client.ts`)
* `workflows.ts` (capability graph)
* `generated/types.d.ts` (from OpenAPI; used for strong typing)

**Example `client.ts` (sketch):**

```ts
import fetch from "node-fetch";
import { db } from "../../storage/supabase"; // or prisma client instance

export async function ccRequest<T>(method: string, url: string, body?: any, qs?: Record<string,string>) {
  const base = "https://api.companycam.com"; // adjust per service
  const token = process.env.COMPANYCAM_API_KEY!;
  const fullUrl = new URL(base + url);
  if (qs) Object.entries(qs).forEach(([k,v]) => v && fullUrl.searchParams.set(k, v));

  const started = Date.now();
  const res = await fetch(fullUrl, {
    method,
    headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/json" },
    body: body ? JSON.stringify(body) : undefined
  });
  const json = await res.json().catch(() => ({}));
  await logApiCall({ service: "companycam", method, url: fullUrl.toString(), request: {body, qs}, response: json, status: res.status, latencyMs: Date.now()-started });
  if (!res.ok) throw new Error(`CompanyCam API ${res.status}: ${JSON.stringify(json)}`);
  return json as T;
}
```

**Example `tools.ts` (sketch):**

```ts
import { z } from "zod";
import { ccRequest } from "./client";

export const companycamTools = {
  "companycam.search_project": async (args: { name?: string; address?: string }) => {
    const data = await ccRequest<any>("GET", "/v1/projects", undefined, { name: args.name ?? "", address: args.address ?? "" });
    // Return best candidate or candidates list for disambiguation
    const candidates = (data?.projects ?? []).map((p:any) => ({ id: p.id, name: p.name, address: p.address }));
    if (candidates.length === 1) return { project_id: candidates[0].id, candidates };
    return { candidates }; // executor will detect ambiguity and ask user
  },
  "companycam.create_project_conversation": async (args: { project_id: string; message: string }) => {
    const data = await ccRequest<any>("POST", `/v1/projects/${args.project_id}/conversations`, { message: args.message });
    return { conversation_id: data?.id ?? "unknown" };
  }
};
```

> You’ll map real endpoints/params using your OpenAPI files. The above is illustrative.

---

## 9) HTTP API (for the web app)

`/api/chat` – main entry

* **POST** `{ conversationId?, message }`
* Flow: Route → Plan → if needs clarification → return `{ ask: "question", choices? }`
* If plan is ready → return **Plan Preview** `{ plan, steps }` (status `awaiting_user`)
* **POST** `/api/execute` with `{ taskId, confirm: true, disambiguation?: {choiceId} }` to run
* Returns final result + links (e.g., project URL if available)

**Auth (dev):** `Authorization: Bearer ${AUTH_DEV_TOKEN}`

---

## 10) Minimal Web UI (Next.js)

* Header with company logo (`/public/logo.png`)
* Chat area (messages)
* Plan Preview card with:

  * Service + Intent
  * Steps summary
  * “Run” button (required)
  * If disambiguation needed: list candidates (radio select)
* Execution result panel (links, IDs, stdout/stderr if command)

`apps/web/app/page.tsx` (sketch):

```tsx
export default function Page() {
  // state: messages, plan, awaitingConfirm, disambiguation
  // call /api/chat then /api/execute
  // render logo + chat UI
}
```

---

## 11) ngrok (local)

* Start API on `:8080`, Web on `:3000`.
* Tunnel **web** only (simplest): `ngrok http 3000`

  * Web frontend proxies to API via `NEXT_PUBLIC_API_BASE_URL` (e.g., `http://localhost:8080`)
* Or tunnel API directly if you need webhooks back.

Set `NGROK_URL` in `.env` if you want the backend to include public links in responses.

---

## 12) Docker & Compose

**apps/api/Dockerfile**

```Dockerfile
FROM node:20-slim
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && corepack prepare pnpm@latest --activate
RUN pnpm i --frozen-lockfile
COPY . .
RUN pnpm prisma generate
EXPOSE 8080
CMD ["pnpm", "start"]  # start runs tsx src/server.ts or node dist/server.js
```

**apps/web/Dockerfile**

```Dockerfile
FROM node:20-slim
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN corepack enable && corepack prepare pnpm@latest --activate
RUN pnpm i --frozen-lockfile
COPY . .
RUN pnpm build
EXPOSE 3000
CMD ["pnpm", "start"]
```

**docker-compose.yml (root)**

```yaml
version: "3.9"
services:
  api:
    build: ./apps/api
    env_file: ./apps/api/.env
    ports: ["8080:8080"]
    volumes: ["./apps/api:/app"]
    depends_on: []
  web:
    build: ./apps/web
    env_file: ./apps/web/.env
    environment:
      - NEXT_PUBLIC_API_BASE_URL=http://api:8080
    ports: ["3000:3000"]
    volumes: ["./apps/web:/app"]
    depends_on: [api]
```

Run:

```
docker compose up --build
ngrok http 3000
```

---

## 13) Example E2E Flow (your CompanyCam use case)

User:

> “in companycam i want you to add a project conversation to Ashley Garrison, 2502 Briarbrook Dr Houston, TX 77042. saying 'Glad we wrapped this up'”

1. **Router:** picks `companycam`.
2. **Planner:** emits `TaskSpec`:

```json
{
  "service": "companycam",
  "intent": "add_project_conversation",
  "inputs": {
    "project_hint": {
      "name": "Ashley Garrison",
      "address": "2502 Briarbrook Dr Houston, TX 77042"
    },
    "message": "Glad we wrapped this up"
  }
}
```

3. **Plan Preview shown** (search → create).
4. **Execute:**

   * `companycam.search_project` → candidates.
   * UI asks you to pick the exact project (ALWAYS disambiguate).
   * `companycam.create_project_conversation` with chosen `project_id`.
5. **Return:** success card with conversation id + link.

---

## 14) Testing

* **Unit:** Planner (TaskSpec validity), Router, Tools arg validation (Zod), Command runner (sandbox mode).
* **Integration:** Nock to mock vendors; confirm correct method/path/body; verify disambiguation triggers.
* **Safety tests:** Ensure shell disabled when `ALLOW_SHELL!=1`; timeouts enforced; logs captured.

---

## 15) Logging & Audit

* Log every inbound message, plan, step, API call, and command run.
* Redact tokens with simple patterns: `/Bearer\s+[A-Za-z0-9\-\._]+/g`, env var names, etc.
* Store `ApiCall` + `CommandRun` rows with timestamps and durations.

---

## 16) Security Notes (you said **ANY** commands)

* Default `COMMAND_MODE=SANDBOX` (dockerized Alpine).
* Require explicit toggle to `HOST` and visible “⚠️ Host Command” badge in the UI.
* Require **user confirmation** for every command step.
* Consider limiting `cwd` to a safe base dir.
* Keep `AUTH_DEV_TOKEN` secret; on VM add real auth (e.g., Basic auth behind reverse proxy or Supabase Auth later).

---

## 17) Deploy to Google Cloud VM (lift-and-shift)

1. Create e2-standard-2 VM (Debian/Ubuntu), open ports 80/443 or use Nginx/Caddy.
2. Install Docker + Docker Compose.
3. Copy repo + `.env` files (or use secrets).
4. `docker compose up -d --build`
5. (Optional) Put **Caddy** in front for HTTPS:

   * Caddyfile reverse proxies `:80/:443` → `web:3000` and `api:8080`.
6. Update `.env` `NEXT_PUBLIC_API_BASE_URL` to `http(s)://your-domain/api` if you reverse-proxy through web.

---

## 18) What you must do manually

* **Place OpenAPI files** in `assets/openapi/`.
* **Edit each service’s `config.json`** under `apps/api/src/action-packs/<service>/` to list the **exact endpoints** you want enabled.
* **Populate `.env`** with vendor API keys and OpenAI key.
* **Run `scripts/ingest-openapi.ts`** after adding new OpenAPI files to generate types.
* **Add/adjust workflows** in `workflows.ts` per service for your usual tasks.

---

## 19) Quick Commands

```bash
# First-time setup
pnpm i -w
cd apps/api && pnpm prisma migrate dev && cd -
pnpm tsx scripts/ingest-openapi.ts

# Dev (without Docker)
pnpm --filter @multibot/api dev
pnpm --filter @multibot/web dev

# With Docker
docker compose up --build

# ngrok
ngrok http 3000
```

---

## 20) Nice-to-haves (later)

* Supabase Auth + RLS for multi-user
* Job queue (BullMQ) for long tasks
* Webhooks per vendor (store event receipts)
* Observability: OpenTelemetry → Grafana Cloud / Honeycomb
* CLI client for power use

---

If you want, I can spit out the initial **server.ts**, **Next.js page.tsx**, **Prisma schema**, and a **CompanyCam action pack** stub in one go so you can paste into Cursor and hit build.
